%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% (01) Input Settings
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{settings.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% (02) DOCUMENT INFORMATION - FROM YAML METADATA
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\DocTitle}{شروع برنامه‌نویسی جاوا}

\newcommand{\CourseTitle}{برنامه‌سازی پیشرفته و کارگاه}

\newcommand{\Semester}{بهار ۱۴۰۴}

\newcommand{\FirstProfessor}{دکتر‌ احمدیان}

\newcommand{\SecondProfessor}{}

\newcommand{\Writers}{آرمان حسینی، کیانا پهلوان، مریم صادقی}

\newcommand{\Faculty}{دانشکده ریاضی و علوم کامپیوتر}

\newcommand{\University}{دانشگاه صنعتی امیرکبیر}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DOCUMENT BODY
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% === TITLE PAGE ===
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{titlepage}
	\centering
	\vspace*{1cm}
	
	%— Smaller logo (20% of text width)
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.20\textwidth]{images/logo-fa.png}
	\end{figure}
	
	\vspace{1cm}
	
	{\fontsize{18}{28}\selectfont \textbf{\CourseTitle} }
	
	\vspace{3cm}
	
	{\fontsize{22}{28}\selectfont \textbf{\DocTitle} }
	
	\vspace{3cm}
	
	{\fontsize{14}{22}\selectfont \rl{نگارش:}}\\
	\vspace{0.5cm}
	{\fontsize{16}{22}\selectfont \textbf{ \Writers } }

	
	\vspace{1cm}
	
	{\fontsize{14}{22}\selectfont \rl{استاد درس:}}\\
	\vspace{0.5cm}
	{\fontsize{16}{22}\selectfont \textbf{ \FirstProfessor } }
	
	
	\vfill
	
	{\fontsize{14}{18}\selectfont \textbf{\Faculty} }\\
	\vspace{0.5cm}
	{\fontsize{14}{18}\selectfont \textbf{\University} }
	\vspace{0.5cm}
	
	\par
	
	{\fontsize{14}{18}\selectfont \textbf{\Semester} }
	
\end{titlepage}

%— Switch to our fancy header/footer from this page onward
\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% === TABLE OF CONTENTS ===
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\tableofcontents
\clearpage
\pagestyle{aftertitle}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% === MAIN CONTENT ===
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{\DocTitle}
\section{مقدمه}

این داکیومنت برای آشنایی اولیه با \lr{syntax} زبان جاوا طراحی شده‌است. در
این مسیر قرار است کمی با آن کدنویسی کنیم و مفاهیم پایه‌ای را بیاموزیم.
ممکن است هنگام کار با جاوا، زبان‌هایی مانند \lr{C} یا \lr{C++} را به یاد
بیاورید؛ این طبیعی است، زیرا \lr{syntax} این زبان‌ها شباهت زیادی به
یکدیگر دارد. بسیاری از کارهایی که در این‌جا انجام می‌دهیم، مشابه تجربیاتی
است که احتمالاً قبل‌تر در \lr{C} داشته‌اید.

لپ‌تاپ‌های خود را آماده کنید، ادیتورها را باز کنید و قدم‌به‌قدم با ما پیش
بیایید تا اولین تجربهٔ برنامه‌نویسی با جاوا را کسب کنید. اگر بخشی از این
داکیومنت برایتان ابهام داشت، حتماً سرچ کنید، از تدریس‌یارها بپرسید یا از
\lr{ChatGPT} کمک بگیرید تا برایتان توضیح دهد.

توجه داشته باشید که این داکیومنت برای دست‌به‌کد شدن شما طراحی شده است.
برخی از کلیدواژه‌های جاوا مانند \lr{\texttt{public}}
،\lr{\texttt{static}} ،\lr{\texttt{class}} و غیره در این‌جا توضیح داده
نمی‌شوند و طبیعی است که نسبت به آن‌ها کمی دچار ابهام شوید. نگران نباشید؛
این مفاهیم در جلسات بعدی توضیح داده خواهند شد. تا آن زمان، در صورت تمایل
می‌توانید دربارهٔ آن‌ها پرس‌وجو کنید یا در اینترنت مطالعه داشته باشید.

\section{نترسید و چیزهای مختلف را امتحان کنید!}

قبل از شروع این داکیومنت، خوب است بدانید که قرار است در کدهای اولیهٔ خود
اشتباه‌های زیادی داشته باشید. چیزهای مختلف را امتحان می‌کنید و با خطاهایی
روبه‌رو می‌شوید که شاید ندانید از کجا آمده‌اند، یا حتی اگر علت آن‌ها را
بدانید، ندانید چگونه باید آن‌ها را برطرف کنید.

نترسید!این خطاها و مشکلات بخشی طبیعی از فرآیند یادگیری شما هستند. ابتدا
دربارهٔ آن‌ها در اینترنت سرچ کنید؛ اگر نتیجه نگرفتید، از \lr{ChatGPT}
بخواهید توضیح دهد، و اگر همچنان مسئله حل نشد، از تدریس‌یارها کمک بگیرید.

چیزهای جدید را امتحان کنید، در کدهای مختلف کنجکاوی کنید، و اگر نکتهٔ خوب
و تازه‌ای پیدا کردید، آن را با دیگران به اشتراک بگذارید. در نهایت، حتی
اگر به خطا برخورد کنید، آن را باهم برطرف خواهیم کرد.

\section{اولین برنامه}

برای درست کردن اولین برنامهٔ جاوای خود، \lr{IntelliJ} را باز کنید و از
مسیر زیر، اولین پروژه‌تان را ایجاد کنید:

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{images/intro-to-java-1.png}
\end{figure}

صفحه‌ای مشابه تصویر زیر برایتان باز می‌شود. نام پروژه را انتخاب کنید،
اطمینان داشته باشید که مسیر ذخیره‌سازی صحیح است و حتماً بررسی کنید همان
\lr{JDK} ی که قبل‌تر دانلود کرده‌اید انتخاب شده باشد. من نسخهٔ 25.0.2 را
نصب کرده‌ام و برای این پروژه نیز از همان نسخه استفاده کرده‌ام:

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{images/intro-to-java-2.png}
\end{figure}

با انجام این مراحل، اولین پروژهٔ جاوای شما ساخته می‌شود. باید صفحه‌ای مشابه
این را مشاهده کنید:

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{images/intro-to-java-3.png}
\end{figure}

این، اولین برنامهٔ شماست. با فشردن دکمهٔ مثلثی‌شکل بالای صفحه، برنامه را
\lr{Run} کنید. اگر برنامه به‌درستی \lr{compile} و \lr{run} شود، خروجی‌ای
مشابه تصویر زیر مشاهده خواهید کرد:

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{images/intro-to-java-4.png}
\end{figure}

تبریک! شما اولین برنامهٔ جاوای خود را اجرا کردید.

\subsection{کدی که اجرا کردیم}

بیایید بررسی کنیم کدی که اجرا شد دقیقاً چه بود. منطقا چنین کدی را در
ادیتور خود مشاهده می‌کنید:

\begin{codebox}{java}
void main() {
    IO.println(String.format("Hello and welcome!"));
    for (int i = 1; i <= 5; i++) {
        IO.println("i = " + i);
    }
}
\end{codebox}

اگر این کد را در ادیتور خود نیز کپی کنید، خروجی دقیقاً یکسانی دریافت
خواهید کرد:

\begin{codebox}{java}
public class Main {
    public static void main(String[] args) {
        System.out.println("Hello and welcome!");
        for (int i = 1; i <= 5; i++) {
            System.out.println("i = " + i);
        }
    }
}
\end{codebox}

در کد نسخه دوم، یک کلاس با نام \lr{Main} مشاهده می‌کنید که درون آن متدی
به نام \lr{main} قرار دارد. در جلسات آینده توضیح خواهیم داد که کلاس
چیست، \lr{public} چه مفهومی دارد و چگونه می‌توانید کلاس‌های خود را ایجاد
کنید.

همان‌طور که مشاهده می‌کنید، در نسخهٔ اول هیچ کلاس‌ای به‌صورت صریح تعریف نشده
است، زیرا از قابلیت جدید \lr{implicit Class} در نسخه‌های جدید جاوا
استفاده شده که امکان تعریف کلاس را به‌صورت غیرمستقیم فراهم می‌کند. در
واقع، حتی در این حالت نیز کامپایلر یک کلاس برای شما ایجاد می‌کند، اما این
کلاس به‌طور مستقیم در کد قابل مشاهده نیست و به‌صورت خودکار در پس‌زمینه
تولید می‌شود.

\begin{codebox}{java}
public class Main {  
   // Your code here  
}
\end{codebox}

در این کلاس، متدی با نام \lr{\texttt{main}} مشاهده می‌کنید. در جاوا به
توابع، \lr{Method} گفته می‌شود (توجه داشته باشید که استفاده از واژهٔ
\lr{Function} برای آن‌ها اصطلاح دقیقی نیست). این متد مشابه تابع
\lr{\texttt{main}} در زبان \lr{C} است که قبل‌تر با آن آشنا شده‌اید و نقطهٔ
شروع اجرای برنامه محسوب می‌شود:

\begin{codebox}{c}
public static void main(String[] args) {  
    // Your program starts from here  
}
\end{codebox}

در نسخهٔ ساده‌تر، متد \lr{\texttt{main}} بدون \lr{\texttt{public}} و
\lr{\texttt{static}} نوشته شده است تا تمرکز شما فقط روی ساختار کلی
برنامه باشد.\footnote{شاید برایتان سوال شده‌باشد که
  \lr{\texttt{public static void}} و \lr{\texttt{String[] args}} دقیقاً
  به چه معناست. فعلاً لازم نیست نگران آن‌ها باشید. کلمات
  \lr{\texttt{public}} و \lr{\texttt{static}} به مفاهیمی در برنامه‌نویسی
  شی‌گرا مربوط می‌شوند که در ادامهٔ مباحث آن‌ها را به‌صورت کامل یاد خواهیم
  گرفت.} اما از اینجا به بعد از شکل کامل آن استفاده می‌کنیم، زیرا این
دقیقاً همان شکلی است که ماشین مجازی جاوا \lr{(JVM)} برای اجرای برنامه
انتظار دارد. در جلسات آینده، دربارهٔ \lr{JVM} نیز به‌طور مفصل صحبت خواهیم
کرد.

اما کلمهٔ \lr{\texttt{void}} احتمالاً برایتان آشناست. وقتی در تعریف یک متد
از \lr{\texttt{void}} استفاده می‌کنیم، یعنی آن متد هیچ مقداری را به‌عنوان
خروجی برنمی‌گرداند. در اینجا نیز متد \lr{\texttt{main}} فقط اجرا می‌شود و
مقداری بازنمی‌گرداند.

توی \lr{\texttt{main}}، شما کد زیر را مشاهده می‌کنید:

\begin{codebox}{java}
System.out.println("Hello and welcome!");
\end{codebox}

این تکه کد برای چاپ \lr{\texttt{"!Hello and welcome"}} نوشته شده‌است. اگر
این خط را حذف کرده و دوباره بنویسید، متوجه خواهید شد که دستور
\lr{println} علاوه بر رشته‌ها (String)، می‌تواند انواع دادهٔ دیگری مانند
\lr{int} و \lr{boolean} را نیز چاپ کند. بنابراین می‌توانید با همان دستور،
مقادیر متنوعی را در خروجی چاپ کنید:

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{images/intro-to-java-5.png}
\end{figure}

این یکی از قابلیت‌های کاربردی \lr{IntelliJ} است که امکان مشاهدهٔ نوع و نام
پارامترهای یک متد و همچنین نوع خروجی آن را فراهم می‌کند. این ویژگی
می‌تواند در فرآیند کدنویسی کمک قابل‌توجهی به شما داشته باشد. اکنون که به
انواع داده‌ای مانند \lr{int} و \lr{boolean} و سایر نوع‌ها اشاره شد، بیایید
نخستین متغیرهای خود را در جاوا تعریف کنیم.

\section{متغیرها}

کد روی صفحه را به کد زیر تغییر دهید:

\begin{codebox}{java}
public class Main {  
   public static void main(String[] args) {  
      int a = 10;  

      System.out.println(a);  
   }  
}
\end{codebox}

در این کد، متغیر \lr{a} را از نوع \lr{\texttt{int}} تعریف کرده‌ایم، مقدار
اولیهٔ 10 را به آن داده‌ایم و سپس مقدار آن را چاپ کرده‌ایم. به
\lr{\texttt{int}} \texttt{،boolean} \texttt{،float} و انواع مشابه آن‌ها،
\lr{data type} گفته می‌شود. \lr{data} type‌های اصلی جاوا که به آنها
\lr{Primitive data types} هم گفته می‌شود، به همراه رنجی که پوشش می‌دهند،
در جدول زیر آمده‌اند. همانند زبان C، نباید مقداری خارج از رنج تعریف‌شده
برای هر \lr{type} به آن اختصاص دهید.

\begin{table}[H]
\centering
\setLTR
\begin{tabular}{lll}
\hline
\textbf{\lr{Type}} & \textbf{\lr{Definition}} & \textbf{\lr{Approximate range or precision}} \\
\hline
\texttt{boolean} & \lr{Logical Value} & \texttt{true} \lr{or} \texttt{false} \\
\texttt{char} & \(16\)\lr{-bit, Unicode character} & \(64k\) \lr{characters} \\
\texttt{byte} & \(8\)\lr{-bit, signed integer} & \(-128\) \lr{to} \(127\) \\
\texttt{short} & \(16\)\lr{-bit, signed integer} & \(-32, 768\) \lr{to} \(32,676\) \\
\texttt{int} & \(32\)\lr{-bit, signed integer} & \(-2.1\mathrm{e}9\) \lr{to} \(2.1\mathrm{e}9\) \\
\texttt{long} & \(64\)\lr{-bit, signed integer} & \(-9.2\mathrm{e}18\) \lr{to} \(9.2\mathrm{e}18\) \\
\texttt{float} & \(32\)\lr{-bit, IEEE 754, floating-point value} & \(6-7\) \lr{significant decimal places} \\
\texttt{double} & \(64\)\lr{-bit, IEEE} 754 & \(15\) \lr{significant decimal places} \\
\hline
\end{tabular}
\end{table}

می‌توانید به‌صورت مشابه، متغیرهایی از هر یک از این typeها تعریف کرده و
آن‌ها را چاپ کنید:

\begin{codebox}{java}
public class Main {
   public static void main(String[] args) {
      int a = 10;
      double b = 3.14;
      boolean c = true;
      char d = 'a';  
  
      System.out.println(a);  
      System.out.println(b);  
      System.out.println(c);  
      System.out.println(d);  
    }  
}
\end{codebox}

خروجی این کد، همان‌طور که انتظار می‌رود، به شکل زیر است:

\begin{codebox}{text}
10
3.14
true
a

Process finished with exit code 0
\end{codebox}

در java، یک \lr{\texttt{type}} برای متغیرهاتون به اسم
\lr{\texttt{String}} هم دارید، که البته جزو \lr{primitive data} typeها
نیست. برای نمونه \lr{\texttt{!Hello and welcome}}ای که در مثال اولتون
\lr{\texttt{print}} کردید، نمونه‌ای از همین \lr{\texttt{type}} بود.
می‌توانید به شکل زیر یک \lr{\texttt{String}} را تعریف کنید:

\begin{codebox}{java}
public class Main {
   public static void main(String[] args) {  
      String str = "Hello, World!";  
  
      System.out.println(str);  
   }  
}
\end{codebox}

علاوه بر این، جاوا دستوری مجزا برای چاپ به سبک \lr{\texttt{printf}} در
زبان \lr{C} دارد:

\begin{codebox}{java}
String name = "Kiana";  
int age = 27;  

System.out.printf("Name: %s\nAge: %d\n", name, age);
\end{codebox}

شما می‌توانید تمام عملیات‌های ریاضی که در زبان‌هایی مانند \lr{C} روی
متغیرها انجام می‌دادید، در اینجا نیز انجام دهید. طبیعتا، جاوا نیز مانند
سایر زبان‌ها، اولویت عملگرهای ریاضی را رعایت می‌کند:

\begin{table}[H]
\centering
\setLTR
\begin{tabular}{llll}
\hline
\textbf{\lr{Precedence}} & \textbf{\lr{Operator}} & \textbf{\lr{Operand type}} & \textbf{\lr{Description}} \\
\hline
1 & \texttt{++,\ -\/-} & \lr{Arithmetic} & \lr{Increment and decrement} \\
1 & \texttt{+,\ -} & \lr{Arithmetic} & \lr{Unary plus and minus} \\
1 & \texttt{\textasciitilde{}} & \lr{Integral} & \lr{Bitwise complement} \\
1 & \texttt{!} & \lr{Boolean} & \lr{Logical complement} \\
1 & \texttt{(\ type\ )} & \lr{Any} & \lr{Cast} \\
2 & \texttt{*,\ /,\ \%} & \lr{Arithmetic} & \lr{Multiplication, division, remainder} \\
3 & \texttt{+,\ -} & \lr{Arithmetic} & \lr{Addition and substraction} \\
3 & \texttt{+} & \lr{String} & \lr{String concatenation} \\
4 & \texttt{\textless{}\textless{}} & \lr{Integral} & \lr{Left shift} \\
4 & \texttt{\textgreater{}\textgreater{}} & \lr{Integral} & \lr{Right shift with sign extension} \\
4 & \texttt{\textgreater{}\textgreater{}\textgreater{}} & \lr{Integral} & \lr{Right shift with no extension} \\
5 & \texttt{\textless{},\ \textless{}=,\ \textgreater{},\ \textgreater{}=} & \lr{Arithmetic} & \lr{Numeric comparison} \\
5 & \texttt{instanceof} & \lr{Object} & \lr{Type comparison} \\
6 & \texttt{==,\ !=} & \lr{Primitive} & \lr{Equality and inequality of value} \\
6 & \texttt{==,\ !=} & \lr{Object} & \lr{Equality and inequality of reference} \\
7 & \texttt{\&} & \lr{Integral} & \lr{Bitwise AND} \\
7 & \texttt{\&} & \lr{Boolean} & \lr{Boolean AND} \\
8 & \texttt{\^{}} & \lr{Integral} & \lr{Bitwise XOR} \\
8 & \texttt{\^{}} & \lr{Boolean} & \lr{Boolean XOR} \\
9 & \texttt{\textbackslash{}\textbar{}} & \lr{Integral} & \lr{Bitwise OR} \\
9 & \texttt{\textbackslash{}\textbar{}} & \lr{Boolean} & \lr{Boolean OR} \\
10 & \texttt{\&\&} & \lr{Boolean} & \lr{Conditional AND} \\
11 & \texttt{\textbackslash{}\textbar{}\textbackslash{}\textbar{}} & \lr{Boolean} & \lr{Conditional OR} \\
12 & \texttt{?:} & \lr{N/A} & \lr{Conditional ternary operator} \\
13 & \texttt{=} & \lr{Any} & \lr{Assignment} \\
\hline
\end{tabular}
\end{table}

می‌توانید هنگام تعریف متغیر، آن را مقداردهی نکنید و صرفا به نوشتن typeشون
اکتفا کنید:

\begin{codebox}{java}
public static void main(String[] args) {  
   int a;  
}
\end{codebox}

با این حال، حتماً باید پیش از استفاده از متغیر، به آن مقدار اختصاص دهید؛
در غیر این صورت، جاوا اجازهٔ کامپایل شدن برنامه را نخواهد داد. به عنوان
مثال، اگر تلاش کنید تا کد زیر را اجرا کنید:

\begin{codebox}{java}
int a;  
System.out.println(a);
\end{codebox}

جاوا خطای زیر را نشان میدهد:

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{images/intro-to-java-6.png}
\end{figure}

زمانی که یک متغیر را هنگام تعریف مقداردهی می‌کنید، می‌توانید از کلیدواژهٔ
\lr{var} استفاده کنید تا کامپایلر جاوا به‌صورت خودکار نوع متغیر را بر
اساس مقدار اولیهٔ آن تشخیص دهد. در این حالت، دیگر نیازی به تعیین دستی نوع
متغیر نخواهد بود.

\begin{codebox}{java}
var a = 10;  
var b = 20;  

System.out.println(a + b);
\end{codebox}

در مثال بالا، چون مقادیر 10 و 20 به \lr{a} و \lr{b} داده شده‌اند،
کامپایلر تشخیص می‌دهد که این دو متغیر از نوع \lr{int} هستند و مطابق آن
رفتار می‌کند. توجه داشته باشید که \lr{var} یک \lr{data type} جدید نیست،
بلکه صرفاً روشی برای ساده‌تر کردن نوشتن کد است. لازم نیست برای همه
متغیرها، typeهای آن‌ها را بنویسید. کامپایلر نوع متغیرها را براساس مقدار
اولیه ای که دریافت می‌کند، تشخیص میدهد.

\section{لیترال‌ها}

اکنون کد زیر را در \lr{IDE} خود اجرا کنید:

\begin{codebox}{java}
public static void main(String[] args) {  
   long a = 99999999999;  

   System.out.println(a);  
}
\end{codebox}

با تلاش برای اجرای آن، با خطای زیر مواجه خواهید شد:

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{images/intro-to-java-6.png}
\end{figure}

این خطا کمی عجیب به نظر می‌رسد. با وجود آن‌که برای این عدد بسیار بزرگ،از
متغیر \lr{long} استفاده کرده‌اید که از نظر ظرفیت باید توان نگه‌داری آن را
داشته باشد همچنان با خطای \lr{number too large} مواجه می‌شوید. علت چیست؟
خطی را که در آن \lr{a} را تعریف کرده‌اید، با خط زیر جایگزین کنید:

\begin{codebox}{java}
long a = 99999999999L;
\end{codebox}

مشکل برطرف شد، درست است؟ علت خطای قبلی، نوع متغیر \lr{a} نبود؛ زیرا
\lr{long} قادر است اعداد بسیار بزرگ‌تری را نیز در خود ذخیره کند. مسئله
این بود که خود جاوا نمی‌دانست با عدد 99999999999 چگونه برخورد کند: آیا
باید آن را \lr{int} در نظر بگیرد، \lr{long} بداند یا حتی double؟ در نسخهٔ
دوم کد، با گذاشتن \lr{L} در انتهای عدد، به جاوا گفتید که این مقدار از
نوع \lr{long} است و باید همانند یک \lr{long} با آن رفتار شود.

به اعداد و کاراکترهایی که در برنامه \lr{hard code} می‌کنید،
\lr{\texttt{literal}} می‌گن. کد زیر، شامل سه‌ \lr{\texttt{literal}} است:

\begin{codebox}{java}
int r = 10;  
char next_line = '\n';  

System.out.printf("Circle area: %f%c", 3.14 * r * r, next_line);
\end{codebox}

این \lr{literal} ها به‌ترتیب \lr{\texttt{10}}،
\lr{\texttt{'\textbackslash\{\}n'}} و \lr{\texttt{3.14}} هستند. همان‌طور
که قبل‌تر اشاره شد، \lr{literal} ها نیز مانند متغیرها دارای \lr{type}
هستند. برای مثال، عدد \lr{\texttt{123}} از نوع \lr{int} محسوب می‌شود، در
حالی که \lr{123L} از نوع \lr{\texttt{long}} است. همچنین اگر عددی مانند
\lr{\texttt{3.14}} را به‌صورت اعشاری بنویسید، جاوا به‌طور پیش‌فرض آن را از
نوع \lr{double} در نظر می‌گیرد؛ و اگر بخواهید نوع آن \lr{float} باشد،
باید از \lr{3.14F} استفاده کنید. افزون بر این، می‌توانید برای اعداد
اعشاری از نمایش علمی \lr{(scientific notation)} نیز بهره ببرید:

\begin{codebox}{java}
double d = 8.31;  
double e = 3.00e+8;  
float f = 8.31F;  
float g = 3.00e+8F;
\end{codebox}

هنگامی که با اعداد بسیار بزرگ سروکار دارید، می‌توانید برای خواناتر شدن
آن‌ها از علامت \_ میان ارقام استفاده کنید تا تفکیک آن‌ها ساده‌تر شود:

\begin{codebox}{java}
int a = 999999999; // Very hard to read!  
int b = 999_999_999; // Easy :)  

System.out.printf("a = %d, b = %d\n", a, b);
\end{codebox}

در کد بالا، مقادیر \lr{\texttt{a}} و \lr{\texttt{b}} یکسان‌اند، اما یکی
از آن‌ها به‌مراتب خواناتر نوشته شده است!

\section{ثابت‌ها}

در کد زیر، یک \lr{constant} یا همان ثابت به نام \lr{\texttt{MAX\_AGE}}
را در جاوا تعریف کرده‌ایم\footnote{در این‌جا نیز لازم نیست با
  \lr{\texttt{public static}} که پیش از \lr{\texttt{MAX\_AGE}} آمده کاری
  داشته باشید؛ در داکیومنت‌های بعدی به‌طور کامل با آن‌ها آشنا می‌شویم و از
  آن‌ها استفاده خواهیم کرد.}:

\begin{codebox}{java}
public class Main {
   public static final int MAX_AGE = 99;

   public static void main(String[] args) {
      int age = 102;

      if (age > MAX_AGE) {  
         System.out.println("You're too old!");  
      }  
   }  
}
\end{codebox}

کلیدواژهٔ \lr{final} این امکان را به شما می‌دهد که یک \lr{constant} تعریف
کنید. constantها پس از تعریف و مقداردهی، هرگز مقدارشان تغییر نمی‌کند.

\section{شرط‌ها}

شرط‌های جاوا بسیار شبیه به \lr{C} هستند و می‌توانید با \lr{syntax} زیر از
آن‌ها استفاده کنید:

\begin{codebox}{java}
int radius = 10;

if (radius <= 20) {  
   System.out.println("Radius is too small");  
} else if (radius >= 50 && radius <= 100) {  
   System.out.println("Radius is too big");  
} else {  
   System.out.println("Other stuff");  
}
\end{codebox}

فقط توجه داشته باشید که Stringها را با == مقایسه نکنید. اگر این کار را
انجام دهید، خود \lr{IntelliJ} به شما یک \lr{warning} می‌دهد و پیشنهاد
می‌کند از متد \lr{equals} استفاده کنید:

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{images/intro-to-java-7.png}
\end{figure}

شیوهٔ صحیح مقایسهٔ Stringها در جاوا به این صورت است:

\begin{codebox}{java}
if (a.equals("Arman")) {
   // Do something
}
\end{codebox}

دلیل این موضوع آن است که همان‌طور که قبل‌تر گفتیم، \lr{String} یک
\lr{primitive type} نیست، بلکه یک \lr{reference type} است. در جلسات بعدی
هر دوی این مفاهیم را تعریف می‌کنیم و تفاوت‌های آن‌ها را توضیح خواهیم داد.
همچنین همواره سعی کنید به \lr{warning} ها، \lr{hint} ها و به‌طور کلی
ابزارهایی که \lr{IntelliJ} در اختیارتان قرار می‌دهد توجه کنید. با استفاده
از آن‌ها می‌توانید کد خود را بهبود دهید و نکات ارزشمندی بیاموزید.

\section{حلقه‌ها}

در جاوا، دو نوع اصلی حلقه داریم: \lr{\texttt{for}} و
\lr{\texttt{while}}. اگر آن‌ها را از \lr{C} یا زبان‌های دیگر به خاطر داشته
باشید، تقریباً همان ساختار را دارند.

در کد زیر، یک حلقهٔ \lr{\texttt{for}} صدتایی می‌نویسیم:

\begin{codebox}{java}
for (int i = 0; i < 100; i++) {  
   System.out.println(i);  
   int j = i;  
   // do any other work needed  
}
\end{codebox}

همان‌طور که مشاهده می‌کنید، \lr{syntax} حلقهٔ \lr{\texttt{for}} در جاوا
بسیار شبیه به زبان \lr{C} است و هر کاری که در آن‌جا انجام می‌دادید، در
این‌جا نیز می‌توانید انجام دهید. می‌توانید به‌جای \lr{\texttt{i++}} هر عبارت
مشابه دیگری که تغییری در \lr{\texttt{i}} ایجاد می‌کند قرار دهید. هر دو
\lr{\texttt{for}} زیر صحیح‌اند؛ آن‌ها را اجرا کنید و خروجی‌شان را بررسی
کنید:

\begin{codebox}{java}
for (int i = 0; i < 100; i += 2) {  
    System.out.println(i);  
}
\end{codebox}

\begin{codebox}{java}
for (int i = 0; i < 100;) {  
    System.out.println(i);  
}
\end{codebox}

در حلقهٔ دوم، مقدار \lr{\texttt{i}} را پس از هر \lr{iteration} تغییر
نمی‌دهیم. این موضوع باعث می‌شود تا زمانی که برنامه اجرا می‌شود، مقدار
\lr{\texttt{0}} چاپ شود. حتی حلقهٔ زیر نیز درست است.

\begin{codebox}{java}
for (; true;) {  
    System.out.println("running forever!");  
}
\end{codebox}

تنها بخشی که حضورش در حلقهٔ \lr{\texttt{for}} اجباری است، شرط تکرار حلقه
است؛ مانند همان \lr{\texttt{true}} که در کد بالا قرار داده‌ایم. دو بخش
دیگر را می‌توانید حذف کنید.

حلقهٔ \lr{\texttt{while}} نیز مشابه زبان \lr{\texttt{C}} است و می‌توانیم
آن را به شکل زیر تعریف کنیم.

\begin{codebox}{java}
int count = 10;
while (count > 0) {  
    System.out.println("Counting down: " + count);
    // maybe do other useful things  
    // and decrement our count
    count = count - 1;  
}  
System.out.println("Done");
\end{codebox}

در جاوا، نوع دیگری از حلقه به نام \lr{\texttt{do while}} نیز وجود دارد.
این حلقه شبیه \lr{\texttt{while}} است، با این تفاوت که ابتدا دستورات
داخل آن اجرا می‌شوند و سپس شرط بررسی می‌شود. این فرآیند تا زمانی ادامه
پیدا می‌کند که شرط برقرار باشد. بنابراین، بدنهٔ \lr{\texttt{do while}}
حداقل یک‌بار اجرا می‌شود، حتی اگر شرط \lr{\texttt{while}} از ابتدا نادرست
باشد.

\begin{codebox}{java}
int i = 0;
do {  
    System.out.println(i);  
    i++;  
} while (i < 5);
\end{codebox}

مانند \lr{C} ، در این‌جا نیز می‌توانید از \lr{\texttt{break}} و
\lr{\texttt{continue}} در حلقه‌های خود استفاده کنید:

\begin{codebox}{java}
for (int i = 0; i < 10; i++) {
    if (i == 5)
        continue;  
    System.out.println(i);  
}
\end{codebox}

\begin{codebox}{java}
while(true) {
    if (watchForErrors())
        break;
    // No errors yet so do some work...
}
// The "break" will cause execution to  
// resume here, after the while loop
\end{codebox}

شاید متوجه نشده باشید، اما در دو کد بالا، \lr{\texttt{if}} ها آکولاد
ندارند. در جاوا، اگر بدنهٔ یک \lr{\texttt{if}}، \lr{\texttt{for}}،
\lr{\texttt{while}}، \lr{\texttt{else}} یا هر ساختار بلوکی دیگری تنها یک
خط باشد، نیازی به قرار دادن آکولاد نیست.

\section{متد‌ها}

می‌توانیم در جاوا متدی مانند \lr{\texttt{checkEmail}} را به شکل زیر تعریف
کنیم:

\begin{codebox}{java}
public class Main {
    // this method will return true if the email contains the character '@'  
    // and false otherwise
    public static boolean checkEmail(String email) {
        int emailLength = email.length();

        for (int i = 0; i < emailLength; i++) {
            if (email.charAt(i) == '@') { // email.charAt(i) will return the i-th character of the email
                return true;  
            }  
        }
        return false;  
    }

    public static void main(String[] args) {  
        String email = "kianapahlevan@gmail.com";

        if (!checkEmail(email)) {  
            System.out.printf("%s is not a valid email address\n", email);  
        } else {  
            System.out.println("Ok");  
        }  
    }  
}
\end{codebox}

همان‌طور که مشاهده می‌کنید، تعریف متدها در جاوا از نظر ساختاری بسیار شبیه
به \lr{Function} ها در زبان \lr{C} است؛ بنابراین هر کاری که در \lr{C}
انجام می‌دادید، این‌جا نیز به همان شکل انجام می‌دهید.

مثال بعدی، عدد $n$ ام فیبوناچی را به‌صورت بازگشتی چاپ می‌کند:

\begin{codebox}{java}
public class Main {
    public static int fib(int n) {
        if (n == 0)
            return 1;
        if (n == 1)
            return 1;

        return fib(n - 1) + fib(n - 2);  
    }

    public static void main(String[] args) {
        int n = 10;  
  
        System.out.println(fib(n));  
    }  
}
\end{codebox}

توجه داشته باشید که فعلاً متدهای خود را خارج از کلاس \lr{\texttt{Main}}
تعریف نکنید.

\section{بلوک‌ها}

به هر چیزی که میان دو آکولاد \lr{\texttt{\{\}}} نوشته می‌شود، یک
\lr{block} گفته می‌شود. برای نمونه، کد زیر سه \lr{block} تعریف می‌کند:

\begin{codebox}{java}
public class Main {
    public static void main(String[] args) {
        for (int i = 0; i < 10; i++) {  
            System.out.println(i);  
        }  
    }  
}
\end{codebox}

شاید برایتان جالب باشد بدانید که برای تعریف یک block، الزاماً نیازی به
استفاده از \lr{\texttt{if}} ،\lr{\texttt{for}} یا ساختارهای مشابه نیست و
می‌توانید بدون آن‌ها نیز یک \lr{block} ایجاد کنید:

\begin{codebox}{java}
public class Main {
    public static void main(String[] args) {
        float pi = 3.14F;  
  
        {
            int r = 12;  
            System.out.println(pi * r * r);  
        }  
    }  
}
\end{codebox}

همانند سایر زبان‌ها، متغیرهایی که در یک \lr{block} تعریف می‌شوند، تنها به
همان \lr{block} تعلق دارند؛ به بیان دیگر، \lr{scope} آن‌ها محدود به همان
\lr{block} است. به این متغیرها، متغیرهای محلی یا \lr{local variables}
گفته می‌شود.

به همین دلیل، اگر کد زیر را اجرا کنید:

\begin{codebox}{java}
float pi = 3.14F;  
  
{
    int r = 12;  
}  
  
System.out.println(pi * r * r);
\end{codebox}

با خطای زیر مواجه خواهید شد:

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{images/intro-to-java-8.png}
\end{figure}

این خطا به این معناست که نمی‌توانید از متغیرهای محلی‌ای که داخل \lr{if}
،for، متدها یا هر ساختار بلوکی دیگری تعریف شده‌اند، در بیرون از همان
\lr{block} استفاده کنید.

\section{ورودی}

ورودی گرفتن در جاوا کمی با زبان‌های دیگر تفاوت دارد. برای استفاده از آن،
ابتدا باید یک شی یا \lr{object} از نوع \lr{\texttt{Scanner}} با استفاده
از \lr{\texttt{System.in}} ایجاد کنید. اگر جملهٔ پیشین برایتان نامفهوم
بود، نگران نباشید؛ زمانی که شی‌گرایی را بیاموزید، درک آن برایتان ساده‌تر
خواهد شد. فعلاً کد زیر را در ابتدای متد \lr{\texttt{main}} خود قرار دهید:

\begin{codebox}{java}
var scn = new Scanner(System.in);
\end{codebox}

توجه داشته باشید که برای استفاده از آن، باید
\lr{\texttt{java.util.Scanner}} را \lr{\texttt{import}} کرده باشید. عمل
\lr{\texttt{import}} کردن برای استفاده از کدی است که در فایل فعلی شما
وجود ندارد. کافی است خط زیر را به ابتدای برنامهٔ خود اضافه کنید.

\begin{codebox}{java}
import java.util.Scanner;
\end{codebox}

اکنون می‌توانید از متدهای مختلف \lr{\texttt{scn}} برای خواندن ورودی کاربر
استفاده کنید. برای نمونه، با استفاده از \lr{\texttt{nextInt()}} می‌توانید
عددی را که کاربر وارد می‌کند بخوانید.

\begin{codebox}{java}
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        var scn = new Scanner(System.in);  
  
        System.out.print("Enter your age: ");
        int age = scn.nextInt();

        if (age >= 18) {  
            System.out.println("You're an adult now.");  
        }  
    }  
}
\end{codebox}

این کد را اجرا کنید تا نگاهی نیز به نحوهٔ نمایش ورودی و خروجی در
\lr{IntelliJ} بیندازید. برای خوندن یک \lr{\texttt{String}} از ورودی
کاربر، از\lr{\texttt{nextLine()}} استفاده کنید:

\begin{codebox}{java}
public class Main {
    public static void main(String[] args) {
        var scn = new Scanner(System.in);  
  
        System.out.print("gmail: ");  
        String email = scn.nextLine();

        if (!email.contains("@gmail.com")) {  
            System.out.println("provide a valid gmail address");  
        }  
    }  
}
\end{codebox}

آبجکت \lr{\texttt{Scanner}} متدهای مشابه دیگری نیز در اختیار شما قرار
می‌دهد که می‌توانید به همان شکل از آن‌ها استفاده کنید:

\begin{table}[H]
\centering
\setLTR
\begin{tabular}{ll}
\hline
\textbf{\lr{Method}} & \textbf{\lr{Description}} \\
\hline
\texttt{nextBoolean()} & \lr{Reads a boolean value from the user} \\
\texttt{nextByte()} & \lr{Reads a byte value from the user} \\
\texttt{nextDouble()} & \lr{Reads a double value from the user} \\
\texttt{nextFloat()} & \lr{Reads a float value from the user} \\
\texttt{nextInt()} & \lr{Reads a int value from the user} \\
\texttt{nextLine()} & \lr{Reads a String value from the user} \\
\texttt{nextLong()} & \lr{Reads a long value from the user} \\
\texttt{nextShort()} & \lr{Reads a short value from the user} \\
\hline
\end{tabular}
\end{table}

\section{\lr{Command-Line Arguments}}

شاید تاکنون توضیح نداده باشیم که \lr{\texttt{String[] args}} در ورودی‌های
متد \lr{\texttt{main}} چه نقشی دارد. \lr{\texttt{args}} آرایه‌ای از
ورودی‌هایی است که از طریق \lr{Command-Line} به برنامهٔ شما داده می‌شود. در
ادامه، کاربرد آن را بررسی می‌کنیم.

کد جاوای خود را به کد زیر تغییر دهید:

\begin{codebox}{java}
public class Main {
    public static void main(String[] args) {  
        System.out.println("Given arg: " + args[0]);  
    }  
}
\end{codebox}

از منوی بالای IntelliJ، \lr{Build > Build Project} را انتخاب کنید تا کد
شما کامپایل شود.

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{images/intro-to-java-command-line-1.png}
\end{figure}

پس از انجام این کار، باید در کنار کدهایتان دایرکتوری‌ای به نام \lr{out}
ایجاد شده باشد که شامل نسخهٔ کامپایل‌شدهٔ برنامهٔ شماست:

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{images/intro-to-java-command-line-2.png}
\end{figure}

روی \lr{out} کلیک کنید و سپس وارد \lr{production} شوید تا دایرکتوری‌ای با
نام پروژهٔ خود مشاهده کنید؛ آن را نیز باز کنید.

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{images/intro-to-java-command-line-3.png}
\end{figure}

فایل \lr{\texttt{Main}} که در \lr{\texttt{out}} می‌بینید، نسخهٔ کامپایل‌شدهٔ
برنامهٔ شماست. اگر روی آن دوبار کلیک کنید، \lr{IntelliJ} آن را
\lr{decompile} می‌کند و کدی مشابه کد اصلی‌تان نمایش می‌دهد. روی دایرکتوری
\lr{\texttt{out/production/\{your-project-name\}}} راست‌کلیک کنید و گزینهٔ
\lr{Copy} Path/Reference\ldots{} را انتخاب کنید. صفحه‌ای مشابه زیر برای
شما باز می‌شود. گزینهٔ \lr{Absolute Path} را انتخاب کنید.

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{images/intro-to-java-command-line-4.png}
\end{figure}

اکنون که مسیر خروجی \lr{build} را کپی کرده‌اید، می‌توانید با استفاده از
\lr{command-line} برنامهٔ خود را اجرا کنید.

اگر از \lr{Windows} استفاده می‌کنید، \lr{cmd} و اگر از \lr{macOS} یا
\lr{Linux} استفاده می‌کنید، \lr{terminal} را باز کنید. ابتدا بررسی کنید
که دستور زیر برای شما اجرا شود:

\begin{codebox}{bash}
java --version
\end{codebox}

باید خروجی‌ای مشابه تصویر مشاهده کنید:

\begin{codebox}{bash}
java 25.0.2 2026-01-20 LTS
Java(TM) SE Runtime Environment (build 25.0.2+10-LTS-69)
Java HotSpot(TM) 64-Bit Server VM (build 25.0.2+10-LTS-69, mixed mode, sharing)
\end{codebox}

اگر این‌طور نبود، دربارهٔ مشکل سرچ کنید یا از نزدیک‌ترین تدریس‌یار کمک
بگیرید. در غیر این صورت، با استفاده از دستور \lr{cd} به دایرکتوری خروجی
\lr{build} (که قبل‌تر کپی کرده‌اید) بروید.

\begin{codebox}{bash}
cd /Users/armaho/Projects/Learning/first-java-project/out/production/first-java-project
\end{codebox}

توجه داشته باشید که به‌جای مسیری که در مثال آمده به \lr{cd} داده شده،
باید مسیر مربوط به پروژهٔ خود را وارد کنید. اگر همه‌چیز به‌درستی انجام شده
باشد، می‌توانید با استفاده از دستور زیر برنامهٔ خود را اجرا کنید. عبارتی
مانند \lr{\texttt{ThisIsAnArgument}} که در مثال آمده، یک
\lr{command-line argument} است و یکی از روش‌های دادن ورودی به برنامه
محسوب می‌شود.

\begin{codebox}{bash}
java Main ThisIsAnArgument
\end{codebox}

خروجی شما باید به شکل مورد انتظار نمایش داده شود:

\begin{codebox}{bash}
Given arg: ThisIsAnArgument
\end{codebox}

اگر خروجی صحیح باشد، شما با موفقیت یک \lr{argument} را از طریق
\lr{command-line} خوانده و آن را چاپ کرده‌اید. همچنین می‌توانستید بیش از
یک \lr{argument} داشته باشید.

\begin{codebox}{bash}
java Main arg1 arg2 arg3
\end{codebox}

جاوا تمامی این ورودی‌ها را از طریق آرایهٔ \lr{\texttt{args}} که ورودی متد
\lr{\texttt{main}} است در اختیار شما قرار می‌دهد.

\section{غیرفعال کردن \lr{Inline Completion} در \lr{IntelliJ}}

حالا که با زبان جاوا آشنا شده‌اید، توصیه می‌شود کدهای جلسات ابتدایی کارگاه
و تمرین‌های خود را بدون استفاده از \lr{Inline Completion} بنویسید تا
\lr{IntelliJ} کدها را به‌صورت خودکار کامل نکند. این کار موجب می‌شود مبانی
زبان جاوا را عمیق‌تر بیاموزید. نگران نباشید؛ پس از یکی دو جلسه می‌توانید
دوباره آن را فعال کنید، زیرا برنامه‌نویسان برای افزایش سرعت کدنویسی
روزانه از آن استفاده می‌کنند.

برای غیرفعال کردن این قابلیت، به تنظیمات \lr{IntelliJ} بروید و سپس به
مسیر \lr{Editor > General > Inline Completion} بروید:

\begin{figure}[H]
\centering
\includegraphics[width=0.8\textwidth]{images/intro-to-java-inline-completion-1.png}
\end{figure}

تیک گزینهٔ \lr{Enable automatic completion on typing} را بردارید و دکمهٔ
\lr{Apply} را انتخاب کنید.

\section{چه چیزی یاد گرفتیم؟}

در این داکیومنت آموختید که:

\begin{itemize}
\tightlist
\item
  چگونه یک پروژهٔ جدید جاوا ایجاد و اجرا کنید.
\item
  چگونه ورودی بگیرید و خروجی بدهید.
\item
  انواع متغیرهای پایه در جاوا کدام‌اند و هر یک چگونه تعریف و استفاده
  می‌شوند.
\item
  حلقه‌ها در جاوا چگونه عمل می‌کنند.
\item
  چگونه می‌توانید با استفاده از متدها، کد خود را به بخش‌های کوچک‌تر تقسیم
  کنید.
\item
  بلوک‌ها چیستند.
\end{itemize}

اگر در هر یک از این مفاهیم پرسشی دارید، حتماً آن را با نزدیک‌ترین تدریس‌یار
مطرح کنید. حتی اگر پرسش شما بدیهی به نظر می‌رسد، از مطرح کردن آن خودداری
نکنید. هوشمندانه بودن سؤال نباید معیاری برای پرسیدن یا نپرسیدن آن باشد.
	
	
	
	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}