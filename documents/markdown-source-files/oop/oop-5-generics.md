---
title: Generics
writers:
  - سام قربانی
  - پریا اصحابی
  - مهدی جعفری
semester: بهار ۱۴۰۴
course: برنامه‌سازی پیشرفته و کارگاه
professor: دکتر مهدی قطعی
professor_2: بهنام یوسفی‌مهر
department: دانشکده ریاضی و علوم کامپیوتر
institution: دانشگاه صنعتی امیرکبیر
---
## مقدمه
در برنامه‌نویسی با جاوا، حتماً براتون پیش اومده که بخواین با انواع مختلف داده‌ها کار کنین و نخواین واسه هر نوع، یه کلاس یا متد جدا بنویسین. اینجاست که ویژگی‌ای به نام Generics  حسابی به کار میاد . Generics  از اون قابلیت‌هاییه که هم کدتون رو مرتب‌تر و قابل‌فهم‌تر می‌کنه، هم کمک می‌کنه موقع اجرا با خطاهای عجیب و غریب روبه‌رو نشین. توی این متن قراره ببینیم اصلاً چرا به Generics نیاز داریم، چه مشکلی رو حل می‌کنه، و چطوری می‌تونیم باهاش کدی بنویسیم که هم امن‌تر باشه، هم قابل استفاده مجدد.

## چرا به Generics احتیاج داریم؟
فرض کنید می‌خواهیم یک کلاس `Pair` داشته باشیم که دو مقدار رو نگه داره، مثلاً یک `String` و یک `int`.
```java
public class PaitStringInteger {
    private String first;
    private int second;
    
    public PairStringInteger(String first, int second) {
        this.first = first;
        this.second = second;
    }
    // getters and setters
}
```

حالا اگه بخوایم یک `pair` از یک ترکیب دوتایی دیگه از داده‌ها مثل `int` و `double` داشته باشیم چی؟ می‌تونیم دوباره یه چنین کلاسی بسازیم ولی این دفعه `PairDoubleInteger` باشه:

```java
public class PaitDoubleInteger {
    private double first;
    private int second;
    
    public PairStringInteger(double first, int second) {
        this.first = first;
        this.second = second;
    }
    // getters and setters
}
```

احتمالاً تا همین الآن هم متوجه شده باشید که داریم کار بیهوده‌ای می‌کنیم. اگه بخواهیم تمام ترکیب‌های ممکن رو پوشش بدیم، تعداد کلاس‌ها خیلی زیاد می‌شه و نگه‌داریش واقعاً کابوسه. و همون‌طور که می‌دونید، ما هیچ علاقه‌ای به کدهای تکراری نداریم.

همون‌طور که از جلسه‌ی مربوط به شی‌گرایی و ارث‌بری به یاد دارید، هر کلاسی که توی جاوا تعریف می‌شه، به نوعی (چه مستقیم و چه غیرمستقیم) از کلاس `Object` ارث می‌بره. همچنین، با توجه به مفهومی که از ارث‌بری یاد گرفتید، می‌دونید که اشیا تا حدی قابل‌جایگزینی هستند؛ یعنی اگر یک آبجکت از یک کلاس دیگه ارث برده باشه، می‌تونه به‌جای آبجکت والدش استفاده بشه.

حالا با در نظر گرفتن این‌که همه‌ی کلاس‌ها در نهایت فرزند `java.lang.Object` هستند، چرا از `Object` استفاده نکنیم که بتونیم هر چیزی رو نگه داریم؟

```java
public class Pair {

    private Object first;
	 private Object second;

    public Pair(Object first, Object second) {
        this.first = first;
        this.second = second;
    }
    public Object getFirst() {
        return first;
    }

    public Object getSecond() {
        return second;
    }
}
```

خب الآن فقط یک کلاس داریم که می‌تونه هر چیزی رو نگه داره. ولی این‌جا یک مشکل بزرگ داریم: type safety از بین رفته. مثلاً وقتی می‌خوایم از این کلاس استفاده کنیم:

```java
Pair p = new Pair("age", 25);
String label = (String) p.getFirst();
Integer value = (Integer) p.getSecond();
```

تا این‌جا مشکلی نیست چون درست type cast کردیم. ولی اگر اشتباه کنیم چی؟

```java
Pair p = new Pair("age", 25);
String label = (String) p.getSecond(); // Runtime error!
```

کامپایلر نمی‌تونه جلوی این اشتباه رو بگیره چون همه‌چیز از نوع `Object` هست. پس خطای runtime می‌گیری، که یعنی ممکنه برنامه حین اجرا متوقف بشه، بدون این‌که خطای کامپایل جلوش رو بگیره.

ماجرا یه جورایی مثل یک مهمونی بالماسکه است که توش همه‌ی آبجکت‌ها یک ماسک یک شکل زدن و بین جمعیت گم می‌شن. وقتی آبجکت‌ها از نوع `Object` در می‌آن، کامپایلر دیگه نمی‌تونه تشخیص بده که واقعاً هر کدوم از چه نوعی بودن و ردشون رو گم می‌کنه. حالا کاربر باید خودش بعداً با type cast کردن، این نقاب رو برداره و بفهمه پشت اون ماسک چی بوده. مثل وقتی که می‌خوای ریش مصنوعی یک نفر رو توی مهمونی بِکَنی. اگه اشتباه کنی، ممکنه با یک سورپرایز ناخوشایند روبه‌رو بشی. :)

خیلی از این cast کردن‌ها ممکنه منجر به خطاهایی بشن که موقع کامپایل قابل شناسایی نیستن و این چیزی نیست که ما دنبالش باشیم.

خب قاعدتاً توی چنین شرایطی، باید دنبال راه‌حل باشیم. راه‌حل درست، تمیز و اصولی، استفاده از جنریک‌هاست. با این کار، هم فقط یک کلاس داریم، هم کامپایلر حواسش به نوع‌ها هست تا دیگه به runtime error برنخوریم. نه تنها type safety حفظ می‌شه، بلکه دیگه نیازی به تبدیل (casting) هم نیست.

یکی از مزایای generics اینه که می‌تونید کدهای عمومی‌تر و قابل‌استفاده مجدد بنویسید. به‌جای نوشتن کدهای تکراری برای انواع مختلف داده‌ها، می‌توانید یک کلاس یا متد عمومی بنویسید که بتونه با انواع مختلف کار کنه. به این ترتیب، دیگه نیازی به نوشتن کد جداگانه برای هر نوع داده ندارید.

حالا لازمه ببینیم که چه‌طوری می‌توانیم با جنریک‌ها کار کنیم.

## چه‌طوری می‌توانیم با Generic ها کار کنیم؟

گفتیم که جنریک‌ها به ما کمک می‌کنن تا کلاس‌ها رو برای نوع خاصی از داده‌ها تخصصی کنیم. یعنی یک کلاس جنریک می‌تونه با یک یا چند type parameter تعریف بشه و خودش رو بر اساس اون‌ها سفارشی کنه.

مثلاً اگه به کلاس `Box` تو مثال پایین نگاه کنیم، چیزی شبیه این می‌بینیم:

```java
public class Box<T> {
    private T value;
    
    public void set(T value) {
        this.value = value;
    }

    public T get() {
        return value;
    }
}
```

این‌جا `E` داخل `<>` یک type parameter هست. یعنی `List` یک کلاس جنریکه که برای کامل بودنش، باید نوع مشخصی بهش داده بشه. در این مثال، `E` یعنی نوع عناصری که قراره توی لیست ذخیره بشن.

داخل کلاس، از `E` برای تعریف متغیرها، پارامترهای متد، و نوع بازگشتی متدها، مثل یک نوع واقعی استفاده می‌شه. مثلاً متد `add()` یک مقدار از نوع `E` می‌گیره و `get()` هم یک `E` برمی‌گردونه.

برای استفاده از این کلاس، باید نوع واقعی رو به‌جای `E` مشخص کنیم، مثلاً:

```java
Box<String> myBox = new Box<>();
```

این‌جا یک باکس از `String` ها تعریف کردیم. ولی می‌تونستیم هر نوع شی دیگه‌ای هم بدیم.

حالا اگه کد زیر را در `Main` ران کنیم:

```java
public class Main {
    public static void main(String[] args) {
        Box<String> stringBox = new Box<>();
        stringBox.set("salam");
        System.out.println(stringBox.get());
        Box<Integer> intBox = new Box<>();
        intBox.set(123);
        System.out.println(intBox.get());
    }
}
```

در نهایت، هر جا که از یک نوع استفاده می‌کنیم، چه توی تعریف متغیر، چه پارامتر متد، نوع بازگشتی، یا موقع `new` کردن یک شی، باید نوع جنریک رو کامل کنیم.

**نکته‌ی مهم:**

پارامترهای نوع توی جنریک‌ها باید کلاس باشن، نه primitive ها مثل `int` و یا `Boolean` برای همین به‌جای `int` از `Integer` استفاده کردیم.

فرض کنید ما آبجکت زیر رو تعریف کنیم:

```java
Box<String> stringBox;
```

مثل این بود که از اول، کلاس `Box` رو به حالت زیر تعریف کرده باشیم:

```java
public class Box {
    private String value;
    public void set(String value) {
        this.value = value;
    }

    public String get() {
        return value;
    }
}
```

انگار ما کلاس `Box` رو تخصصی کردیم تا فقط با `String` کار کنه و دیگه نمی‌تونه هر نوع `Object` ای رو بپذیره.
الآن با این `Box` مخصوص `String` ها می‌تونیم با خیال راحت کار کنیم. کامپایلر اجازه نمی‌ده چیزی غیر از `String` (یا زیرکلاس‌هاش) به `Box` اضافه کنیم. همچنین وقتی از `get()` استفاده می‌کنیم، دیگه نیازی به cast کردن نداریم چون نوع خروجی از قبل مشخصه.

حالا فرض کنید می‌خواهیم یک جعبه بسازیم که بتونیم هر نوع چیزی رو توش بذاریم و بر داریم اما یک شرط داره، این جعبه باید حتماً از یک قاعده‌ی کلی پیروی کنه. این‌جا همون جاییه که یک کلاس جنریک باید بتونه یک interface جنریک رو implement کنه. بریم ببینیم چه‌طوری:

مثلاً برای همون مثال `Box` که قبل‌تر داشتیم، یک اینترفیس براش می‌نویسیم که شمل متود `set` و `get` است.

```java
interface Container<T> {
    void set (T value);
    T get();
}
```

می‌خواهیم کلاس `box` مون بر اساس همین الگو پیش بره.

```java
public class Box<T> implements Container<T> {
    private T value;
    @Override
    public void set(T value) {
        this.value = value;
    }
    @Override
    public T get() {
        return value;
    }
}
```

حالا که با کلاس‌های جنریک آشنا شدیم و فهمیدم چه‌طور می‌تونیم ساختارهایی بسازیم که با انواع مختلف داده‌ها کار کنن، وفتشه بریم سراغ یک بخش مهم دیگه از جنریک‌ها.

### متدهای جنریک
گاهی وقت‌ها فقط کلاس‌ها نیستن که باید انعطاف‌پذیر باشن، بلکه خود متدها هم ممکنه نیاز داشته باشن با انواع مختلف داده کار کنن، بدون این‌که بخوایم برای هر نوع یک نسخه جدا بنویسیم.
یعنی در واقع شما می‌خواید یک کلاس غیرجنریک بنویسید، اما توی اون فقط یک متد کوچولوی جنریک داشته باشین.

فرض کنید می‌خوایم یک متود تعریف کنیم که یک آرایه بگیره و عنصر اولش رو برگردونه. می‌دونیم آرایه ممکنه از هر نوعی باشه، ولی بدون استفاده از Generic باید حالت‌بندی کنیم برای هر نوع آرایه مختلف مثل `int` و `String` و... متود مربوط به خودش را بنویسیم. پس این‌جا بهتره که از مفهوم Generic استفاده کنیم.

```java
public class Main {
    public static <T> getFirstElement(T[] array) {
	    if (array == null || array.length == 0) {
		    return null;
	    }
    }
}
```
توی کد بالا، وسط کلاسی که خودش Generic نیست، ما یک متد کوچیک جنریک تعریف کردیم. یک مقدار با این متد ور برین و ببینید که چه‌طور می‌تونید صداش کنید. آیا لازمه برای اون هم توی `<>` نوع type parameter تون رو مشخص کنید؟

یا مثلاً متود زیر، دو تا ورودی از یک نوع می‌گیره و مقایسه‌شون می‌کنه و اون که بزرگ‌تره رو خروجی می‌ده.

```java
public static <T extends Comparable<T> T getMax(T a, T b) {
    return (a.compareTo(b) > 0) ? a : b;
}
```

## مفهوم Bounding (Upper-Bound) و محدودسازی در Generics
خیلی وقت‌ها نمی‌خواید هر نوعی توی جنریک استفاده بشه. حالا شاید بپرسین چرا مگه هدف جنریک همین نبود که کلی‌سازی کنه؟ کی این‌کارو باید کرد؟

وقتی یک کلاس یا متد جنریک تعریف می‌کنین، به‌طور پیش‌فرض می‌تونه با هر نوعی از داده‌ها کار کنه.

اما بعضی وقتا فقط استفاده و به زبان بهتر اجازه کار با برخی نوع‌های خاص منطقی هست.

مثلاً فرض کنید برای یک برنامه مثل ماشین حساب که فقط با اعداد سر و کار داریم، کلاسی نوشتید برای یک عملیات ریاضی، مثلاً مربع گرفتن:
```java
class Calculaor<T> {
    public double square(T value) {
        return value * value;
    }
}
```
به‌نظرتون مشکلش چیه؟
این نوع استفاده رو ببینید:
```java
Calculator<String> calc = new Calculator<>();
calc.square("hello");
```
خب این منطقی نیست که مربع یه رشته رو داشته باشیم. اصلاً چنین چیزی وجود نداره. و این کار ارور می‌ده به همین دلیلی که دیدید.

حالا راه‌حلش چیه؟ گذاشتن محدودیت روی نوع داده قابل‌استفاده یا به عبارتی کران‌دار کردنش که همون Bounding هست.

پس توی این مثال باید محدودش کنیم به اعداد. برای این کار لازمه از کلاسی به اسم `Number` استفاده کنیم. `Number` یک کلاس از پیش‌تعریف‌شده (built-in) در Java هست که توی `java.lang` قرار داره، و همه‌ی کلاس‌های عددی ازش ارث‌بری می‌کنن.

مثلاً این‌طوری (بیش‌تر بدانید):
```java
abstract class Number {
    abstract double doubleValue();
}

class Integer extends Number {
    int value;
    Integer(int value) { this.value = value; }
    
    @Override
    double doubleValue() {
        return (double) value;
    }
}
```

پس وقتی یک متغیر از نوع `Number` داشته باشید، می‌تونید به راحتی ازش `doubleValue()` بخواهید. پس این کار رو می‌کنید:
```java
class Calculator<T extends Number> {
    public double square(T value) {
        return value.doubleValue() * value.doubleValue();
    }
}
```

حالا برگردیم به جنریک.

در واقع با این کار داریم می‌گیم فقط نوع‌هایی مثل `Integer`، `Double`، یا هر چیزی که از `Number` ارث‌بری کرده باشه، مجازن. به‌طور دقیق‌تر دارین می‌گین که
«هر چیزی که `T` هست، باید از `Number` ارث برده باشه، بنابراین مثلاً کامپایلر مطمئنه که `T` این متد رو داره : `doubleValue()` »
یعنی حتی اگه کسی بیاد از `Calculator<Integer>` یا `Calculator<Double>` یا حتی `Calculator<BigDecimal>` استفاده کنه، مشکلی نیست، چون همه‌شون از `Number` اومدن.

ولی اگه کسی بگه:
```java
Calculator<String> calc = new Calculator<>();
```
به ارور می‌خوره! چون `String` از `Number` ارث نبرده و بنابراین متد `doubleValue()` هم نداره.
وقتی می‌گین `T extends Number`، داریم به کامپایلر می‌گیم «من تضمین می‌کنم که `T` حداقل یک `Number` هست.»، کامپایلر با خیال راحت می‌تونه `doubleValue()`، `intValue()`، و بقیه‌ی متدهای `Number` رو روش صدا بزنه.

یک نکته یه‌کم حرفه‌ای‌تر:
اگر به‌جای کلاس `Number` از یک interface استفاده کنین (مثلاً `Comparable<T>`)، باز هم همین ایده کار می‌کنه.
```java
class Sorter<T extends Comparable<T>> {
    public T max(T a, T b) {
        return a.compareTo(b) > 0 ? a : b;
    }
}
```
گاهی وقت‌ها نمی‌خواید بگین دقیقاً چه نوعی داریم، فقط می‌خوایم بگیم «یک چیزی» هست.

## Wildcard چیه و چرا و چه‌طوری استفاده می‌شه؟
اگه خیلی خلاصه مرور کنید، تا این‌جا یاد گرفتید که چه‌طوری با Generics کلاس یا متدهایی بنویسید که بشه با انواع مختلف داده‌ها به‌صورت type-safe کار کرد. اما یک جایی ممکنه به مشکل بخورید. مثلاً فرض کنین یک متد نوشتین که قراره یک لیست رو چاپ کنه. خب منطقیه که بنویسین:

```java
public void printList(List<Object> list) {
    for (Object obj : list) {
        System.out.println(obj);
    }
}
```

ولی اگه این کد رو با یک لیست از نوع `List<Integer>` صدا بزنین، کامپایلر بهتون ایراد می‌گیره! چرا؟ مگه `Integer` هم خودش یک نوع `Object` نیست؟ پس چرا نمی‌تونیم یک `List<Integer>` رو به متدی بدیم که لیست از نوع `Object` می‌گیره؟

ماجرا اینه که در جاوا، `List<Object>` و `List<Integer>` هیچ ربطی به هم ندارن. حتی اگه `Integer` یک `Object` باشه، `List<Integer>` هیچ‌وقت فرزند `List<Object>` نیست. این با چیزی که توی خیلی از زبون‌ّای دیگه مثل Kotlin یا Python می‌بینین که راحت می‌تونن لیستی از انواع مختلف رو قبول کنن. ولی جاوا سخت‌گیرتره. (بعداً به بررسی دقیقش می‌رسیم.)
حالا دقیقاً این‌جاست که Wildcard وارد می‌شه تا نجاتمون بده. Wildcard یعنی می‌تونین بگین «یه لیستی می‌خواهیم، حالا مهم نیست از چه نوعیه، فقط یک چیزی داخلش هست!».
پس به‌جای `List<Object>`، بنویسین `List<?>`.

مثلاً متد بالا رو این‌طوری اصلاح کنید:
```java
public void printList(List<?> list) {
    for (Object obj : list) {
        System.out.println(obj);
    }
}
```
الآن دیگه این متد می‌تونه با `List<String>`، `List<Integer>`، یا حتی `List<MyCustomClass>` هم کار کنه. این همون انعطاف‌پذیریه که با wildcard به دست می‌آد.

### چرا از wildcard ها استفاده می‌کنیم و چرا `List<Object>` کافی نیست؟
بیاید دقیق‌تر بررسی کنیم که چرا به‌جای `List<?>` از `List<Object>` استفاده نکنید؟ در ظاهر، به‌نظر می‌رسد این دو باید رفتاری شبیه به هم داشته باشند، اما تفاوت مهمی بین آن‌ها وارد دارد. از کد بالا به یاد دارید که فقط می‌تواند لیست‌هایی از نوع `Object` را بپذیرد. به عبارت دیگر، اگر لیستی از نوع `List<Object>` یا `List<Integer>` یا هر نوع دیگری را به این متد بدهید، با خطای کامپایل مواجه خواهید شد.

دلیل این محدودیت آن است که `List<String>` یک زیرنوع (subtype) از `List<Object>` محسوب نمی‌شود، حتی اگه `String` زیرنوع `Object` باشد. داستان این اتفاق یک خاصیت توی جاواست که بهش Generic Type Invariance می‌گن. یعنی چی؟ بیاید تا روی یک مثال عملی بررسیش کنین.

فرض کنین دو تا کلاس `Animal` و `Dog` دارید و `Dog` از `Animal` ارث‌بری کرده:
```java
class Animal {}
class Dog extends Animal {}
```

حالا یک سوال: اگه یک لیست از `Dog` داشته باشید (`List<Dog>`)، آیا می‌توانید اون رو به یک متد که انتظار `List<Animal>` داره، پاس بدید؟

مثلاً بگید:
```java
public void addAnimal(List<Animal> animals) {
    animals.add(new Animal());
}
```

و این‌جوری صداش کنید:

```java
List<Dog> dogs = new ArrayList<>();
addAnimal(dogs);
```

این کد بهتون ارور می‌ده، چون در حقیقت درسته که `Dog‍` یک ساب‌تایپ (زیرنوع) از `Animal` هستش و خب منطقیه که یک لیست از سگ‌ها هم یک ساب‌تایپ از یک لیست از حیوانات باشه. اما جاوا چنین چیزی رو قبول نداره. به بیان دیگه جنریک‌ها توی جاوا invariant هستن. خب این خاصیت به چه دردی می‌خوره؟ برگردیم به مثالمون، چرا `List<Dog>` نمی‌تونی جای `List<Animal>` بشینه؟

جواب ساده است: چون اگه جاوا اجازه می‌داد این کار رو بکنین، می‌تونستین به یک لیست از سگ، یک حیوان غیرسیگ مثل گربه یا حتی خود کلاس `Animal` اضافه کنید، اون موقع دیگه لیست خالصی از سگ‌ها نیست!

```java
List<Dog> dogs = new ArrayList<>();
addAnimal(dogs);
```

که متد استفاده‌شده به این صورت هست:

```java
public void addAnimal(List<Animal> animals) {
    animals.add(new Animal());
}
```

خب الآن توی `dogs` که قراره فقط `Dog` باشه، یک `Animal` ریخته شده که ممکنه `Dog` نباشه. این یعنی بعداً هرجایی که بخواهید با فرض `Dog` بودن تمام اعضای اون لیست کار کنید، ممکنه به مشکل بخورید.
راه‌حل چیه؟ Wildcards

خب، گفتیم که جنریک‌ها invariant هستن، پس نمی‌تونین یک `List<Dog>` رو جایی پاس بدین که `List<Animal>` انتظار می‌ره. اما اگه فقط می‌خواهید از لیست بخونید (و چیزی بهش اضافه نکنید)، می‌تونید از wildcard استفاده کنید.

```java
public void readAnimals(List<? extends Animal> animals) {
    for (Animal a : animals) {
        System.out.println(a);
    }
}
```

این یک لیستیه از چیزهایی که یا خود Animal هستند یا یکی از زیرکلاس‌هاش. این‌طوری می‌تونید بدون مشکل `List<Cat>`، `List<Dog>`، یا هر نوع دیگه‌ای از `Animal` رو به این متد پاس بدید. ولی حواستون باشه که نمی‌تونید چیزی به این لیست اضافه کنید. (به‌جز `null`) چون کامپایلر نمی‌دون نوع واقعی لیست دقیقاً چیه، فقط می‌دونه «یک چیزی که `Animal` هست.» پس اگه بخواهید یک `Animal` ساده بهش اضافه کنید، ممکنه اون لیست در واقع `List<Cat>` باشه، که در این صورت نمی‌تونید یک `Animal` عمومی بهش اضافه کنید. برای همینه که جاوا اجازه‌ی add کردن نمی‌ده.

حالا برعکسش چیه؟ اگه فقط می‌خواهید به لیست چیزی اضافه کنید و کاری به خوندنش ندارید، می‌تونید از wildcard پایین‌رو (lower-bounded wildcard) استفاده کنید:

```java
public void addDog(List<? super Dog> list) {
    list.add(new Dog());
}
```

این یک لیست از چیزیه که خود `Dog` یا یکی از والدینش مثل `Animal` یا حتی `Object` هست. شما مطمئنید که هر چی که باشه، `Dog` می‌تونه توش جا بشه. پس `list.add(new Dog())` کاملاً اوکیه.

ولی این بار برعکسه؛ نمی‌تونید با اطمینان چیزی از لیست رو بخونید و نوعش رو بدونید. چون ممکنه لیست چیزی از نوع `Object` داشته باشه. تنها چیزی که می‌دونید اینه که لیست مناسب اضافه کردن `Dog` بوده و نه بیش‌تر.


| هدف ما چیه؟            | چی استفاده کنیم؟ | ما می‌تونیم چی کار کنیم؟                             |
| ---------------------- | ---------------- | ---------------------------------------------------- |
| فقط می‌خواید «بخونید»  | `? extends T`    | بخونید، اما نمی‌تونید چیزی اضافه کنید.               |
| فقط می‌خواید «بنویسید» | `? super T`      | بنویسید، اما نمی‌تونید حین خوندن نوعش رو متوجه بشید. |
یک نکته‌ی مهم: Wildcard فقط توی استفاده از کلاس‌ها و متدهای Generic کاربرد داره، نه توی تعریفشون. یعنی نمی‌تونین یک کلاس بنویسی مثل `class Box <?> {...}` این اصلاً مجاز نیست. اون‌جا باید نوع `Generic` مشخص بشه. (مثلاً `T` یا `E` یا هر چی که بخواین.)

### انواع Wildcard
- **Unbounded Wildcard (?)**
این نوع Wildcard هیچ محدودیتی روی نوع داده ندارد. به عبارت دیگر، شما می‌توانید لیستی از هر نوع داده‌ای حتی `Object` داشته باشید.

```java
public void printList(List<?> list) {
    for (Object obj : list) {
        System.out.println(obj);
    }
}
```

در این‌جا `?` به این معناست که این پارامتر متد می‌تواند یک لیست از هر نوعی باشد.

- **Upper Bounded Wildcard (? extends T)**
این نوع Wildcard به شما این امکان رو می‌ده که پارامترهای نوع فقط از یک نوع خاص (یا زیرکلاس‌های اون) استفاده کنن. یعنی شما می‌خواهید فقط با انواع خاصی کار کنید که از یک کلاس یا اینترفیس خاص ارث برده باشن. در واقع، این‌طوری می‌تونید محدودیت‌هایی بذارید که فقط داده‌هایی که با اون کلاس یا اینترفیس هماهنگ هستن وارد بشن، نه هر نوع داده‌ای.

```java
public void printNumbers(List<? extends Number> list) {
    for (Number number : list) {
        System.out.println(number);
    }
}
```

در این مثال فقط لیست‌هایی که از نوع `Number` یا زیرکلاس‌های آن (مثل `Integer`،`Doubl`، `Float` و...) هستند، پذیرفته می‌شوند.
- **Lower Bounded Wildcard (? super T)**
به شما این امکان را می‌دهد که پارامترهای نوع، از یک نوع خاص یا هر نوعی که از اون ارث برده باشه، استفاده کنن. به عبارت دیگر، این نوع wildcard زمانی کاربرد داره که بخواهید نوع داده‌ها را محدودتر کنید، ولی در عین حال اجازه بدید که کلاس‌های دیگه هم بتونن از اون استفاده کنن. این‌طوری می‌تونید محدوده‌ی استفاده رو کنترل کنید، ولی در عین حال انعطاف‌پذیری بیش‌تری برای انواع مختلف داده‌ها داشته باشید.

```java
public void addNumbers(List<? super Integer> list) {
	 list.add(1);
    list.add(2);
}
```

در این‌جا، لیست فقط می‌تواند انواع `Integer` یا والدین آن‌ها (مثل `Number` و یا `Object`) را بپذیرد.

### چگونه Wildcard ها به مدیریت پیچیدگی کد کمک می‌کنند؟
با استفاده از Wildcard، می‌توانید کدهای جنریک را طوری بنویسید که برای انواع مختلف داده‌ها قابل استفاده باشه، بدون این‌که نیاز باشه دقیقاً نوع داده رو مشخص کنید. این ویژگی مخصوصاً وقتی که کد شما باید با داده‌های مختلف از انواع مختلف کار کنه، خیلی مفید می‌شه. یعنی می‌تونید کد رو بازتر و انعطاف‌پذیرتر بنویسید و نیاز به تغییرات زیاد برای انواع مختلف داده‌ها نداشته باشید.

بیایم با یک مثال ساده و سریع مرورشون کنیم:

```java
public class WildcardExample {
    public static void main(String[] args) {
        List<Integer> intList = List.of(1, 2, 3);
        List<Double> doubleList = List.of(1.1, 2.2, 3.3);
        
        // Upper Bounded Wildcard
        printNumbers(intList);
        printNumbers(doubleList);
        
        // Lower Bounded Wildcard
        List<Object> objectList = new ArrayList<>();
        addNumbers(objectList);
    }
    
    // Upper Bounded Wildcard
    public static void printNumbers(List<? extends Number> list) {
        for (Number number : list) {
            System.out.println(number);
        }
    }
    
    // Lower Bounded Wildcard
    public static void addNumbers(List<? super Integer> list) {
        list.add(1);
    }
}
```

در این کد می‌بینید که چه‌طور wildcard ها به شما این امکان رو می‌دهند که متدها رو عمومی‌تر و انعطاف‌پذیرتر بنویسید، بدون این‌که نیازی به مشخص کردن نوع دقیق داده‌ها داشته باشید.

لیست‌های مختلف داریم.
`intList` که یک لیست از `Integer` هاست.
`doubleList` که یک لیست از `Double` هاست.

- **Upper Bounded Wildcard (? extends Number):**
توی این مدت می‌خواهیم از هر لیستی که توش از انواع مختلف `Number` استفاده شده رو چاپ کنیم. یعنی هم `Integer` هم `Double` و حتی انواع دیگه‌ای که از `Number` ارث می‌برن.

متد `printNumbers` می‌تونه هر نوع داده‌ای که از `Number` مشتق شده رو دریافت کنه و چاپ کنه. به همین دلیل، وقتی این متد رو به لیست‌های `intList` و `doubleList` می‌دین، هیچ مشکلی پیش نمی‌آد.

- **Loewr Bounded Wildcard (? super Integer)**
این‌جا دارین لیستی رو می‌سازین که می‌تونه هر چیزی که از `Integer` کوچک‌تر باشه رو قبول کنه. یعنی می‌تونی `Integer n` رو به این لیست اضافه کنی و حتی کلاس‌هایی مثل `Object` رو هم بهش بریزین.

در متد `addNumbers` می‌گید که می‌خواهید حداقل `Integer` رو به لیست اضافه کنین، نه کم‌تر از اون. این باعث می‌شه که بتونین نوع `Integer` و نوع‌هایی که والدشون `Integer` هست رو به لیست اضافه کنید.

#### خلاصه
- با Upper Bounded Wildcard می‌تونید با هر لیستی که از یک نوع خاص ارث برده، کار کنید. (مثلاً تمام چیزهایی که از `Number` ارث می‌برن.)
- با Lower Bounded Wildcard می‌تونید هر چیزی رو که از یک نوع خاص پایین‌تر باشه، به لیست اضافه کنید. (مثلاً می‌تونی `Integer` و هر چیزی که بالاتر از اون باشه رو اضافه کنی.)

این‌ها باعث می‌شن که برنامه‌هاتون انعطاف‌پذیرتر بشن و دیگه نیازی نباشه دقیقاً نوع داده‌ها رو مشخص کنید.

در آخر می‌بینید که Wildcard ها در جنریک‌ها ابزارهای خیلی قدرتمندی هستند که می‌توانند به شما کمک کنند که کدهای خودتون رو انعطاف‌پذیرتر و قابل استفاده مجددتر بنویسید. این ابزارها به شما اجازه می‌دهند که با انواع مختلف داده‌ها کار کنید، در حالی که همچنان از مزایای type safety در زبان جاوا بهره‌مندید.