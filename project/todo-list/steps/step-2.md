# مقدمه

توی سوال آخر قدم قبلی، دیدین که دیتابیس شما یه مشکل داره، اون هم این که می‌شه موجودیت‌های داخل دیتابیس رو، بدون استفاده از متد update خود دیتابیس تغییر داد. مثالش رو هم دیدیم:

```java
public class Main {
    public static void main(String[] args) {
        Human ali = new Human("Ali");
        Database.add(ali);

        ali.name = "Ali Hosseini";

        Human aliFromTheDatabase = (Human) Database.get(ali.id);

        System.out.println("ali's name in the database: " + aliFromTheDatabase.name);
    }
}
```

توی این کد، برخلاف خواستهٔ ما اسم ‍‍‍‍`ali` توی دیتابیس ما به ‍‍`Ali Hosseini` تغییر پیدا کرده بود.

اگر این مشکل رو برطرف نکنیم، در آینده برامون دردسرساز می‌شه. ممکنه موجودیت‌های دیتابیس‌مون بدون این که ما خبر داشته باشیم از بیرون دیتابیس تغییر بکنن و این اصلا چیز خوبی نیست. توی این قدم، می‌خوایم این مشکل رو برطرف کنیم.

# کدزنی

## کپی کردن reference typeها

شما توی [داکیومنت «مقدمه‌ای بر شی‌گرایی»](https://drive.google.com/file/d/1218BmqwE3GxJMNm9-R4zshzOXTSNg9Rb/view?usp=share_link)، با موضوع «passing by reference» آشنا شدین. اگر نشدین یا یادتون رفته، برین و بخش «Reference Typeها» رو مرور کنین.

علت تغییر موجودیت‌های دیتابیس با تغییر فیلدهای `ali`، اینه که مموری شما در برنامهٔ بالا همچین شکلی داره:
![مموری برنامه‌تون](https://i.postimg.cc/SsXLL5jv/temp-Image-Vwac44.avif)

همون‌طور که می‌بینید، خونهٔ صفرم آرایهٔ `entities` و `ali`، هر دو به یک آبجکت `Human` توی heap اشاره می‌کنن و به خاطر همین هر تغییری توی `ali` باعث تغییر دیتابیس می‌شه. دقت کنید که چون `String` هم reference typeئه، توی heap ذخیره شده.

ما دوست نداریم این‌طور باشه، دوست داریم که بعد از اضافه شدن یه موجودیت به دیتابیس، کپی‌ای از اون موجودیت داخل دیتابیس ذخیره بشه که با تغییرات بیرون دیتابیس، تغییر نکنه. به عبارتی، ما دوست داریم مموری‌مون به شکل زیر باشه:
![شکل دلخواه مموری](https://i.postimg.cc/Hn1QSRWk/temp-Image-Ytup-B5.avif)

اگر موفق بشیم، دیگه با تغییرات `ali`، دیتابیس‌مون تغییر نمی‌کنه. چون که اساسا دیگه دیتابیس و `ali` به یک `object` اشاره نمی‌کنن.

## تفاوت shallow copy و deep copy

برای کپی کردن `object`ها، دو راه وجود داره. یکی‌شون shallow copyئه و دیگری deep copy. این‌جا متوقف شید، راجع به تفاوت‌های این دو تحقیق کنین و بررسی کنید که کدوم یکی از اون‌ها برای کار ما بهتره.

## افزودن متد ‍`copy`

کلاس `Entity`، تا الآن کلاس خیلی ساده‌ای بوده و توی خودش فقط فیلد `id` رو نگه می‌داشته. الآن قراره که یک متد `copy` به اون اضافه کنیم.

وظیفهٔ این متد، اینه که کپی کاملی از یک `Entity` به ما بده. به خاطر این که ممکنه فیلدهای موجودیت‌های مختلف متفاوت باشه، این متد `abstract`ئه و وظیفهٔ پیاده‌سازی‌ش با بچه‌های کلاس `Entity` مثل `Human`ئه. نهایتا، سیگنیچر این متد به شکل زیره:

```java
public abstract Entity copy();
```

حالا پیاده‌سازی این متد رو توی کلاس `Human` بنویسید:

```java
@Override
public Human copy() {
    Human copyHuman = new Human(name);
    copyHuman.id = id;        

    return copyHuman;
}
```

یه چیزی توی این override جالبه، این که با این که ما متد کلاس پدر رو override کردیم، ولی خروجی اون رو از `Entity` به `Human` تغییر دادیم. مگر غیر از این بود که سیگنیچر متد‌های override شده بین پدر و فرزندانش باید یکسان باشن، پس چرا می‌تونیم این کار رو بکنیم؟ تحقیق کنید.

توی این متد، ما آبجکتی جدید از روی آبجکت فعلی‌مون (منظورم همون `this`ئه) ساختیم که تمام فیلدهاش شبیه به آبجکت قبلیه، ولی توی heap، توی جای متفاوتی ذخیره شده و تغییرات این دو آبجکت روی هم تاثیری نمی‌ذاره:

```java
Human ali = new Human("Ali");
Human aliCopy = ali.copy();

System.out.println("ali's name: " + ali.name);
System.out.println("aliCopy's name: " + aliCopy.name);
System.out.println();

ali.name = "Ali Hosseini";

System.out.println("ali's name: " + ali.name);
System.out.println("aliCopy's name: " + aliCopy.name);
```

خروجی این کد به شکل زیره:

```
ali's name: Ali
aliCopy's name: Ali

ali's name: Ali Hosseini
aliCopy's name: Ali
``` 

می‌بینید که تغییرات `ali` روی `aliCopy` تاثیری نداره.

## تغییرات متدهای دیتابیس

حالا باید بعضی از متدهای دیتابیس‌تون رو عوض کنید و به جای `entity`، باید `entity.copy()` رو توی دیتابیس ذخیره کنید و خروجی بدین.

### متد get

توی این متد به جای خود `entity`، باید `entity.copy()` رو خروجی بدین.

### متد add و update

توی این متدها به جای `entity`، باید `entity.copy()` رو توی دیتابیس ذخیره کنید.

# تست

حالا، دوباره با همون `main` قبلی، کدتون رو اجرا کنید:

```java
public class Main {
    public static void main(String[] args) {
        Human ali = new Human("Ali");
        Database.add(ali);

        ali.name = "Ali Hosseini";

        Human aliFromTheDatabase = (Human) Database.get(ali.id);

        System.out.println("ali's name in the database: " + aliFromTheDatabase.name);
    }
}
```

حالا باید خروجی زیر رو ببینید:

```
ali's name in the database: Ali
```

می‌بینید که با تغییر اسم `ali`، دیتابیس تغییری نکرده.

با این کد بیشتر ور برین. ببینید می‌تونید فیلدهای متغیرهای داخل دیتابیس رو به شکل دیگه‌ای عوض کنید؟ مطمئن بشید که کار می‌کنه و مشکلی نداره.

# فعالیت امتیازی

توی کد بالا، از متد `copy` برای کپی کردن یک `object` استفاده کردیم. خود جاوا هم توی کلاس `Object` یک متد به اسم ‍‍`clone` با کاربری‌ای مشابه داره. 

آیا می‌‌تونید به جای اضافه کردن متد `copy`، از متد `clone` برای کپی کردن `object`هاتون استفاده کنید؟ 

راجع به این متد تحقیق کنید و ببینید چطور کار می‌کنه. بعد از این که یه مقدار توی اینترنت باهاش آشنا شدین، برای این که خیلی پیشرفته‌تر باهاش آشنا بشین و بفهمین دقیقا چه کار می‌کنه می‌تونین یه نگاه به **Item 11 - Override clone judiciously** از کتاب **Effective Java** نوشتهٔ **Joshua Bloch** بندازین. (این کتاب رو می‌تونید از [libgen](https://www.libgen.is) دانلود کنید، البته که گوشه و کنار اینترنت هم پیدا می‌شه):

![کتاب Effective Java](https://i.postimg.cc/fWgdHf6h/temp-Image-Lyj-Yg-Y.avif)

# گزارش‌ کار

توی یک فایل pdf، پاسخ سوالات زیر رو بدین:

## سوال ۱

تفاوت deep copy و shallow copy چیه؟ هر کدوم در چه سناریوهایی به درد می‌خورن؟ این‌جا، توی متد `copy` باید از کدوم استفاده بشه؟

## سوال ۲

چرا تونستیم توی کلاس `Human`، متد `copy` رو با نوع خروجی متفاوتی override کنیم؟ آیا نباید سیگنیچر متد حین override کردن ثابت می‌موند؟

## سوال ۳

یک اسکرین‌شات از خروجی کدتون حین اجرای کد بخش «تست کد» این‌جا بذارین.

## سوال ۴ (امتیازی)

توضیح مختصری راجع به متد `clone` بنویسید. این متد برای چی استفاده می‌شه؟

## سوال ۵ (امتیازی)

اگر از متد `clone` استفاده کرده باشین، می‌دونید که باید اینترفیس `Cloneable` رو توی `object`هاتون پیاده‌سازی کنید. یک نکتهٔ جالب راجع به این اینترفیس اینه که هیچ متدی نداره!

```java
package java.lang;

public interface Cloneable {
}
```

نه، اشتباه نشده. کد بالا، کد کاملِ اینترفیس `Cloneable`ئه. ولی اگر این اینترفیس هیچ متدی نداره، پس چه تاثیری روی کلاس ما می‌ذاره؟

(برای جواب این سوال، می‌تونید به کتاب **Effective Java** که بالاتر معرفی کردیم مراجعه کنید)